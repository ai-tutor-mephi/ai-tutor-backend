## HTTP

**Hypertext Transfer Protocol (HTTP)** — сетевой протокол прикладного уровня, который изначально предназначался для получения с серверов гипертекстовых документов в формате HTML, а с течением времени стал универсальным средством взаимодействия между узлами как Всемирной паутины, так и изолированных веб-инфраструктур.
Пример HTTP запроса:
```
GET /index.html HTTP/1.1    <- стартовая строка
Host: www.example.com               |  •доменное имя сервера
User-Agent: Mozilla/5.0             |  •метаданные о клиенте
Accept: text/html                   |  •поддерживаемый контент      
Accept-Language: en-US,en;q=0.5     |  •настройки соединения      <- заголовки
Accept-Encoding: gzip, deflate      |
Connection: keep-alive              |  •настройки соединения 
Cookie: some-key=some-var           |  •настройки безопасности
Origin: www.example.com             |
```

HTTP определяет несколько методов запросов:
- **GET** — самый распространённый метод, используется для получения ресурсов. Идемпотентен и может кэшироваться.
- **POST** — отправка данных на сервер (например, форма). Не идемпотентен и обычно не кэшируется.
- **PUT** — обновление или создание ресурса. Идемпотентен: повторный запрос приводит к тому же результату.
- **DELETE** — удаление ресурса. Идемпотентен, но не кэшируется.
- **HEAD** — аналог GET, но сервер возвращает только заголовки без тела. Полезно для проверки ресурсов или кеширования.
- **OPTIONS** — позволяет узнать, какие методы поддерживает сервер для конкретного ресурса.
- **TRACE** — метод для отладки, возвращает «эхо» запроса. Практически не используется в реальном вебе.
- **PATCH** — частичное обновление ресурса, отличается от PUT тем, что меняет только отдельные поля.

Пример HTTP ответа:
```
HTTP/1.1 200 OK
Content-Length: 1024              <- длина, тип и кодировка контента
Content-Type: text/html
Server: Apache/2.4.1 (Unix)       <- метаданные сервера
Expires: Mon, 26 Oct 2024         <- политику кэширования данных
Connection: keep-alive            <- настройки соединения
Access-Control-Allow-Origin: *    <- настройки безопасности
X-Some-Custom-Header: some-value  <- кастомные параметры и etc (указываются с префиксом X-)

<!DOCTYPE html> .......           <- полезная нагрузка
```

![[Pasted image 20251011001425.png|555]]

## HTTPS (2000)

**HTTPS** — это защищенная версия протокола HTTP, которая использует шифрование для безопасного обмена данными между клиентом и сервером.
- HTTPS — это HTTP поверх TLS/SSL, то есть обычный HTTP с шифрованием.
- Основная задача — защита данных в пути между клиентом и сервером. Никто не сможет перехватить логины, пароли или банковские данные.
- Как это работает:
	1. Клиент и сервер обмениваются сертификатами и договариваются о ключах шифрования (TLS handshake).
	2. После установки безопасного соединения весь HTTP-трафик шифруется.
- Дополнительные преимущества HTTPS:
	- Аутентификация сервера — браузер проверяет сертификат и удостоверяется, что соединение с правильным сайтом.
	- Целостность данных — изменения данных в пути будут обнаружены.
	- Улучшение SEO и доверие пользователей: браузеры помечают HTTP-сайты как «небезопасные».
- Важно: всё, что работает по HTTP, можно «зашифровать» через HTTPS, и это современный стандарт работы веба.

## Продвинутые механизмы

### Транзитные заголовки

В современных веб-инфраструктурах запросы часто проходят через балансировщики нагрузки, прокси и CDN. Обычные заголовки Host и IP могут изменяться, поэтому используются транзитные заголовки.
•X-Real-Ip — реальный IP-клиента
•X-Forwarded-For — хранит цепочку промежуточных балансировщиков нагрузки и прокси-серверов
•X-Forwarded-Host — хранит исходный Host-заголовок (на случай его модификации)
•X-Forwarded-Proto — хранит предыдущий протокол
•Forwarded — стандартный заголовок, объединяющий все предыдущие

### Кэширующие заголовки

Кэширование HTTP позволяет сократить нагрузку на сервер и ускорить загрузку страниц.
Основные заголовки для управления кэшированием:
- Cache-Control — главный инструмент. Позволяет задавать, можно ли кэшировать ресурс, кем и на какой срок (public, private, max-age, no-cache).
- Expires — указывает точную дату и время устаревания ресурса. После этого браузер должен снова запросить ресурс у сервера.
- ETag — уникальный идентификатор версии ресурса. Клиент отправляет его обратно в заголовке If-None-Match, чтобы сервер проверил, изменился ли ресурс, и вернул 304 Not Modified, если изменений нет.
Грамотное кэширование сильно ускоряет работу сайтов и экономит трафик, но ошибки в заголовках могут приводить к устаревшему контенту или излишней нагрузке на сервер.
Пример: браузер кэширует изображение сайта на неделю, и повторная загрузка страницы не требует нового запроса к серверу.

### Печеньки (Cookie)

**Cookie** — это нативный механизм браузера для хранения небольших данных и их передачи между клиентом и сервером.
Основное назначение — сохранение состояния между запросами, так как HTTP сам по себе stateless (не хранит информацию о предыдущих взаимодействиях).

Основные функции Cookie:
- Аутентификация пользователей — сервер может запомнить, что клиент уже вошёл в систему.
- Хранение персональных данных и настроек — язык интерфейса, темы, предпочтения.
- Поддержка открытой сессии — чтобы не требовать повторного логина на каждой странице.
- Сбор статистической информации — например, для аналитики посещений.
Cookie передаются в заголовках HTTP и могут быть прочитаны сервером при каждом запросе.

### CORS (Content Origin Resource Sharing)

**CORS (Cross-Origin Resource Sharing)** — механизм, который позволяет браузеру безопасно запрашивать ресурсы с другого домена.
Важно: по умолчанию браузеры запрещают кросс-доменные запросы для защиты от угроз типа XSS и CSRF.
Как это работает:
- Клиент отправляет preflight-запрос (OPTIONS) к серверу, чтобы проверить, разрешено ли использовать конкретный метод и заголовки.
- Если сервер отвечает положительно, браузер выполняет основной запрос.
- Если нет — запрос блокируется, и доступ к данным запрещён.
Основные заголовки CORS:
- Access-Control-Allow-Origin — разрешённые домены.
- Access-Control-Allow-Methods — разрешённые методы (GET, POST и др.).
- Access-Control-Allow-Headers — разрешённые заголовки.

Пример: фронтенд-сайт на example.com хочет получить данные с API на api.example.org. Без CORS браузер не позволит это сделать.

## Современные версии HTTP

### QUIC (2013)

**QUIC** — это новый транспортный протокол, разработанный Google для ускорения веб-соединений. Изначально использовался для YouTube и сервисов Google.

Ключевые особенности:
- Построен на UDP, а не на TCP. Это даёт гибкость: QUIC избегает проблем TCP, таких как head-of-line blocking и сложная установка соединения.
- Всегда шифрует данные с помощью TLS 1.3, что делает соединение безопаснее по сравнению с традиционным TCP+HTTPS.
- Не требует повторного установления соединения при потере пакетов — соединение остаётся активным и устойчивым.
- Поддерживает многопоточные потоки данных: одновременно можно передавать и получать несколько потоков, без блокировки друг друга.
Важно: QUIC стал основой HTTP/3, ускоряет веб, делает соединения более стабильными и безопасными.

Пример: страницы YouTube и Google загружаются быстрее на медленных или нестабильных сетях благодаря QUIC.

### HTTP/2 (2015)

**HTTP/2** — это эволюция HTTP/1.1, направленная на повышение скорости и эффективности работы веба.

Основные нововведения:
- Бинарный формат вместо текстового. Это упрощает парсинг и снижает риск ошибок при обработке данных.
- Мультиплексирование: несколько запросов и ответов могут передаваться одновременно по одному соединению, что устраняет проблемы блокировки (head-of-line blocking).
- Сжатие заголовков (HPACK) — уменьшает объём данных, передаваемых в заголовках, ускоряя загрузку.
- Приоритеты: клиент может указать, какие ресурсы важнее, чтобы сервер отдавал их в первую очередь (например, изображения для видимой части страницы могут загружаться раньше CSS).
- Server Push: сервер может заранее отправлять ресурсы, которые клиент, скорее всего, запросит, сокращая задержку и ускоряя отображение страницы.
Важно: HTTP/2 полностью совместим с HTTPS и совместим с логикой HTTP/1.1, но значительно ускоряет работу современных сайтов.

Пример: при загрузке страницы с множеством картинок и скриптов HTTP/2 позволяет всё передавать по одному соединению без ожидания завершения предыдущих запросов.

### HTTP/3 (2019)

**HTTP/3** — это новое поколение протокола, стандартизованное в 2020 году, построенное поверх QUIC вместо TCP.

Основные особенности:
- Использование QUIC вместо TCP снижает задержки при установлении соединения, соединение устанавливается быстрее.
- Решена проблема head-of-line blocking: если один пакет теряется, блокируется только конкретный поток, а не все запросы, что повышает общую производительность.
- Поддержка 0-RTT (Zero Round Trip Time) позволяет начать передачу данных почти сразу при повторном соединении, сокращая время ожидания.
- Всегда шифрован: безопасность встроена на уровне транспортного протокола, нет необходимости отдельно подключать TLS.
Важно: HTTP/3 делает веб быстрее, устойчивее к потерям пакетов и более безопасным, особенно в мобильных и нестабильных сетях.

Пример: страницы крупных сервисов (YouTube, Google, Cloudflare) загружаются быстрее и стабильнее в HTTP/3, даже при медленных или прерывистых соединениях.

## Head-of-Line blocking

**Head-of-line blocking (HoL)** — это проблема, возникающая при последовательной обработке пакетов в TCP-соединении.
Суть: если один пакет теряется или задерживается, все последующие пакеты не могут быть обработаны, даже если они уже пришли, и это задерживает доставку данных.

В HTTP/1.1 это особенно заметно, когда несколько ресурсов передаются по одному соединению беp мультиплексирования — браузер ждёт завершения одного запроса, прежде чем обработать следующий.

Решение в HTTP/2: мультиплексирование потоков — несколько запросов и ответов могут передаваться параллельно по одному соединению, HoL блокирует только конкретный поток, а не все.

Решение в HTTP/3/QUIC: транспорт построен на UDP, поэтому каждый поток независим, потеря пакета блокирует только свой поток, а остальные продолжают идти без задержки.

Важно: понимание HoL помогает объяснить, почему HTTP/2 и HTTP/3 работают быстрее, и почему старые сайты с HTTP/1.1 могут «тормозить» при множестве ресурсов.

## Протоколы поверх HTTP

### WebSocket

**WebSocket (WS)** — протокол для двусторонней, постоянной связи между клиентом и сервером.

Особенности подключения:
- Соединение начинается как обычный HTTP-запрос (HTTP/1.1 или выше).
- После успешного «handshake» соединение переключается на WebSocket, обеспечивая постоянный канал.
Основное применение:
- Чаты и мессенджеры.
- Онлайн-игры.
- Системы потоковой передачи данных (например, биржевые котировки).

Преимущество WS: сервер и клиент могут отправлять данные в любой момент, без необходимости открывать новый HTTP-запрос для каждого сообщения.

Cтандартный WebSocket (RFC 6455) не работает поверх HTTP/2 напрямую. Он был разработан для работы поверх HTTP/1.1.
1. Классический WebSocket
	1. Начинается с HTTP/1.1 запроса с заголовком Upgrade: websocket.
	2. Сервер отвечает, и соединение «апгрейдится» из HTTP в постоянное TCP-соединение для двустороннего обмена.
	3. Это не совместимо с HTTP/2, потому что HTTP/2 использует мультиплексированные потоки поверх одного TCP и не поддерживает прямой Upgrade так, как это делает HTTP/1.1.
2. HTTP/2 особенности
	1. Потоки в HTTP/2 мультиплексируются поверх одного соединения, есть бинарный протокол, нет «апгрейда» в том виде, как в HTTP/1.1.
	2. Поэтому обычный WebSocket «не понимает» HTTP/2 и не может просто так работать по нему.
3. Обходные пути / альтернативы
	1. WebSocket over HTTP/2: стандарт не утвердился, но есть экспериментальные реализации, например Google работал над «WebSocket over HTTP/2», но это пока не массово.
	2. HTTP/2 + Server-Sent Events (SSE): для однонаправленных потоков.
	3. gRPC / gRPC-Web: двусторонний поток через HTTP/2 (часто используют вместо WebSocket).
	4. HTTP/3 / QUIC: будущие подходы тоже могут менять ландшафт, но это отдельная тема.

### gRPC

**gRPC** — протокол удалённого вызова процедур (RPC), разработанный Google, работающий поверх HTTP/2.

Особенности:
- Использует бинарный формат Protobuf, что обеспечивает низкую задержку и компактную передачу данных.
  ```
  Protobuf — это механизм, который позволяет описывать структуру сообщения на специальном языке (.proto-файл). На его основе для выбранного языка программирования генерируется код, который умеет превращать данные из удобного объектного вида в компактный бинарный поток — и обратно. Protobuf не зависит от конкретного языка или платформы, работает с множеством языков (Java, C++, Python и др.), и поддерживает компактную передачу даже сложных структур данных.
  ```
- Поддерживает двусторонние стримы, что позволяет серверу и клиенту одновременно отправлять данные.
- Подходит для микросервисной архитектуры и распределённых систем: упрощает вызов удалённых функций между сервисами.
Важно: gRPC эффективнее для внутренних сервисов, чем традиционный REST, особенно при работе с большим количеством вызовов и данных, однако несовместим с браузером.

Пример: микросервисная архитектура банка, где один сервис запрашивает данные по счетам у другого сервиса через gRPC.